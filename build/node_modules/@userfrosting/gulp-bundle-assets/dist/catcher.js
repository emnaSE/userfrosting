import { Transform } from "stream";
import { LogLevel } from "./log-levels";
/**
 * All this does is collect all stream data and once all read resolves a promise with the collected chunks.
 */
export class Catcher extends Transform {
    /**
     * @param logger Used for logging events and errors.
     */
    constructor(logger) {
        super({
            objectMode: true
        });
        /**
         * Holds caught stream content.
         */
        this.Results = [];
        this.Logger = (msg, lvl) => logger(`Catcher > ${msg}`, lvl);
        // Set promise
        this.Logger("Creating promise with external completion source", LogLevel.Silly);
        this.Collected = new Promise(resolve => {
            this.Resolve = resolve;
        });
    }
    /**
     * Collects incoming chunks.
     * @param chunk Incoming chunk to catch.
     * @param encoding Its encoding, if applicable.
     * @param callback Callback used to indicate method completion.
     */
    _transform(chunk, encoding, callback) {
        this.Logger("Catching a chunk", LogLevel.Silly);
        this.Results.push(chunk);
        callback();
    }
    /**
     * Resolves collection promise.
     * @param callback Callback used to indicate method completion.
     */
    _flush(callback) {
        this.Logger("Starting resolution of catcher promise", LogLevel.Silly);
        // Ensure promise has had chance to run
        const resolver = () => {
            /* istanbul ignore else */
            if (this.Resolve) {
                this.Resolve(this.Results);
                this.Logger("Catcher promise has resolved", LogLevel.Silly);
                callback();
            }
            else {
                this.Logger("Catcher promise not yet ready, waiting 5ms", LogLevel.Silly);
                setTimeout(resolver, 5);
            }
        };
        resolver();
    }
}
//# sourceMappingURL=catcher.js.map
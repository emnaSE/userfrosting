import Browserify from "browserify";
import { createWriteStream, existsSync, lstatSync, mkdirSync, readFileSync, rmdirSync } from "fs";
import extendObject from "just-extend";
import PQueue from "p-queue";
import { join as joinPathSegments } from "path";
export default async function (userOptions) {
    // Fill in required options
    const options = new Options(userOptions);
    const queue = new PQueue({
        concurrency: options.concurrency
    });
    for (const depName of userOptions.dependencies) {
        // Clone options for dependency
        const depOptions = options.clone();
        // Read dependency info from package
        const pkg = JSON.parse(readFileSync(joinPathSegments(options.inputDir, depName, "package.json")).toString());
        // Skip if no main
        if (!pkg.main)
            continue;
        // Set entry file (browser field not used due to being non-standard and otherwise complex)
        depOptions.browserifyOptions.entries = joinPathSegments(options.inputDir, depName, pkg.main || "./");
        // Set output path
        const targetPath = (() => {
            try {
                if (lstatSync(depOptions.browserifyOptions.entries).isDirectory())
                    // Handle folder
                    return joinPathSegments(options.outputDir, depName, "./index.js");
            }
            catch (_a) {
                // Handle file without extension (assume js)
                return joinPathSegments(options.outputDir, depName, pkg.main + ".js");
            }
            // And finally, handle exact path
            return joinPathSegments(options.outputDir, depName, pkg.main);
        })();
        // Ensure directory tree exists
        try {
            try {
                mkdirSync(targetPath, { recursive: true });
            }
            catch (_a) {
                // Fallback for when recursive fails
                function createDirRecursively(dir) {
                    if (!existsSync(dir)) {
                        createDirRecursively(joinPathSegments(dir, ".."));
                        mkdirSync(dir);
                    }
                }
                createDirRecursively(targetPath);
            }
            rmdirSync(targetPath);
        }
        catch (ex) {
            // No issue if it already exists
            if (ex.code !== "EEXIST")
                throw ex;
        }
        // Add to queue
        queue.add(() => BrowserifyDependency(depName, targetPath, depOptions));
    }
    await queue.onIdle();
}
async function BrowserifyDependency(depName, targetPath, options) {
    const BrowserifyInstance = new Browserify(options.browserifyOptions);
    // Open write stream
    const out = createWriteStream(targetPath, { flags: "w" });
    // Browserify and save script
    BrowserifyInstance.bundle().pipe(out);
    await new Promise(resolve => out.on("finish", resolve));
}
/**
 * Fills in missing options from provided user options to apply defaults.
 */
class Options {
    /**
     * @param userOptions User options to build instance from.
     */
    constructor(userOptions) {
        this.browserifyOptions = userOptions.browserifyOptions ? extendObject(true, {}, userOptions.browserifyOptions) : {};
        this.concurrency = userOptions.concurrency || 4;
        this.dependencies = userOptions.dependencies;
        this.inputDir = userOptions.inputDir;
        this.outputDir = userOptions.outputDir;
    }
    /**
     * Creates a deep clone of the instance.
     */
    clone() {
        return extendObject(true, {}, this);
    }
}
